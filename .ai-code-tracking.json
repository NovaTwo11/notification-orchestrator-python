{
  "version": "1.0",
  "records": [
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/config/settings.py",
      "timestamp": 1762898413937,
      "startOffset": 0,
      "endOffset": 893,
      "codeContent": "from pydantic_settings import BaseSettings\nfrom typing import Optional\n\nclass Settings(BaseSettings):\n    # Aplicaci√≥n\n    app_name: str \u003d \"notification-orchestrator\"\n    app_version: str \u003d \"1.0.0\"\n    port: int \u003d 8088\n    \n    # RabbitMQ\n    rabbitmq_host: str \u003d \"rabbitmq\"\n    rabbitmq_port: int \u003d 5672\n    rabbitmq_user: str \u003d \"guest\"\n    rabbitmq_password: str \u003d \"guest\"\n    \n    # Colas\n    exchange_name: str \u003d \"app.events\"\n    usuarios_queue: str \u003d \"usuarios.events\"\n    sesiones_queue: str \u003d \"sesiones.events\"\n    password_reset_queue: str \u003d \"password.reset.requested\"\n    password_updated_queue: str \u003d \"password.updated\"\n    notifications_queue: str \u003d \"notifications.delivery\"\n    notifications_routing_key: str \u003d \"notifications.send\"\n    \n    # Logging\n    log_level: str \u003d \"INFO\"\n    \n    class Config:\n        env_file \u003d \".env\"\n        case_sensitive \u003d False\n\nsettings \u003d Settings()",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 32
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/models/events.py",
      "timestamp": 1762898458585,
      "startOffset": 0,
      "endOffset": 1898,
      "codeContent": "from pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional, Dict, Any\nfrom enum import Enum\n\nclass NotificationType(str, Enum):\n    USER_WELCOME \u003d \"user_welcome\"\n    LOGIN_NOTIFICATION \u003d \"login_notification\"\n    PASSWORD_RESET \u003d \"password_reset\"\n    PASSWORD_UPDATED \u003d \"password_updated\"\n\nclass UsuarioCreadoEvent(BaseModel):\n    usuario_id: str \u003d Field(alias\u003d\"usuarioId\")\n    email: str\n    nombre: str\n    timestamp: datetime\n    activation_token: Optional[str] \u003d Field(None, alias\u003d\"activationToken\")\n    base_url: Optional[str] \u003d Field(None, alias\u003d\"baseUrl\")\n    \n    class Config:\n        populate_by_name \u003d True\n\nclass SesionIniciadaEvent(BaseModel):\n    usuario_id: int \u003d Field(alias\u003d\"usuarioId\")\n    email: str\n    nombre: str\n    timestamp: datetime\n    ip_address: Optional[str] \u003d Field(None, alias\u003d\"ipAddress\")\n    user_agent: Optional[str] \u003d Field(None, alias\u003d\"userAgent\")\n    device_info: Optional[str] \u003d Field(None, alias\u003d\"deviceInfo\")\n    location: Optional[str] \u003d None\n    \n    class Config:\n        populate_by_name \u003d True\n\nclass PasswordResetSolicitadoEvent(BaseModel):\n    usuario_id: str \u003d Field(alias\u003d\"usuarioId\")\n    email: str\n    nombre: str\n    token: str\n    fecha_solicitud: datetime \u003d Field(alias\u003d\"fechaSolicitud\")\n    \n    class Config:\n        populate_by_name \u003d True\n\nclass PasswordActualizadoEvent(BaseModel):\n    usuario_id: str \u003d Field(alias\u003d\"usuarioId\")\n    email: str\n    nombre: str\n    fecha_actualizacion: datetime \u003d Field(alias\u003d\"fechaActualizacion\")\n    \n    class Config:\n        populate_by_name \u003d True\n\nclass NotificationEvent(BaseModel):\n    type: NotificationType\n    email: str\n    user_name: str \u003d Field(alias\u003d\"userName\")\n    timestamp: datetime\n    additional_data: Optional[Dict[str, Any]] \u003d Field(None, alias\u003d\"additionalData\")\n    \n    class Config:\n        populate_by_name \u003d True\n        use_enum_values \u003d True",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 64
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/services/rabbitmq_consumer.py",
      "timestamp": 1762898467598,
      "startOffset": 0,
      "endOffset": 5616,
      "codeContent": "import pika\nimport json\nimport logging\nfrom typing import Callable\nfrom app.config.settings import settings\nfrom app.models.events import (\n    UsuarioCreadoEvent, \n    SesionIniciadaEvent,\n    PasswordResetSolicitadoEvent,\n    PasswordActualizadoEvent\n)\n\nlogger \u003d logging.getLogger(__name__)\n\nclass RabbitMQConsumer:\n    def __init__(self):\n        self.connection \u003d None\n        self.channel \u003d None\n        self.setup_connection()\n    \n    def setup_connection(self):\n        \"\"\"Establece conexi√≥n con RabbitMQ\"\"\"\n        credentials \u003d pika.PlainCredentials(\n            settings.rabbitmq_user,\n            settings.rabbitmq_password\n        )\n        parameters \u003d pika.ConnectionParameters(\n            host\u003dsettings.rabbitmq_host,\n            port\u003dsettings.rabbitmq_port,\n            credentials\u003dcredentials,\n            heartbeat\u003d600,\n            blocked_connection_timeout\u003d300\n        )\n        \n        self.connection \u003d pika.BlockingConnection(parameters)\n        self.channel \u003d self.connection.channel()\n        \n        # Declarar exchange\n        self.channel.exchange_declare(\n            exchange\u003dsettings.exchange_name,\n            exchange_type\u003d\u0027topic\u0027,\n            durable\u003dTrue\n        )\n        \n        # Declarar colas\n        self._declare_queues()\n        \n        logger.info(\"‚úÖ Conexi√≥n a RabbitMQ establecida\")\n    \n    def _declare_queues(self):\n        \"\"\"Declara todas las colas necesarias\"\"\"\n        queues \u003d [\n            (settings.usuarios_queue, \"usuarios.created\"),\n            (settings.sesiones_queue, \"sesiones.iniciada\"),\n            (settings.password_reset_queue, \"password.reset.requested\"),\n            (settings.password_updated_queue, \"password.updated\"),\n        ]\n        \n        for queue_name, routing_key in queues:\n            self.channel.queue_declare(queue\u003dqueue_name, durable\u003dTrue)\n            self.channel.queue_bind(\n                exchange\u003dsettings.exchange_name,\n                queue\u003dqueue_name,\n                routing_key\u003drouting_key\n            )\n            logger.info(f\"‚úÖ Cola declarada: {queue_name} -\u003e {routing_key}\")\n    \n    def consume_usuarios(self, callback: Callable):\n        \"\"\"Consume eventos de usuarios creados\"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                data \u003d json.loads(body)\n                event \u003d UsuarioCreadoEvent(**data)\n                callback(event)\n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de usuario: {e}\")\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        self.channel.basic_consume(\n            queue\u003dsettings.usuarios_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.usuarios_queue}\")\n    \n    def consume_sesiones(self, callback: Callable):\n        \"\"\"Consume eventos de sesiones\"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                data \u003d json.loads(body)\n                event \u003d SesionIniciadaEvent(**data)\n                callback(event)\n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de sesi√≥n: {e}\")\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        self.channel.basic_consume(\n            queue\u003dsettings.sesiones_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.sesiones_queue}\")\n    \n    def consume_password_reset(self, callback: Callable):\n        \"\"\"Consume eventos de reset de password\"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                data \u003d json.loads(body)\n                event \u003d PasswordResetSolicitadoEvent(**data)\n                callback(event)\n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de password reset: {e}\")\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        self.channel.basic_consume(\n            queue\u003dsettings.password_reset_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.password_reset_queue}\")\n    \n    def consume_password_updated(self, callback: Callable):\n        \"\"\"Consume eventos de password actualizado\"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                data \u003d json.loads(body)\n                event \u003d PasswordActualizadoEvent(**data)\n                callback(event)\n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de password updated: {e}\")\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        self.channel.basic_consume(\n            queue\u003dsettings.password_updated_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.password_updated_queue}\")\n    \n    def start_consuming(self):\n        \"\"\"Inicia el consumo de mensajes\"\"\"\n        logger.info(\"üöÄ Iniciando consumo de mensajes...\")\n        self.channel.start_consuming()\n    \n    def close(self):\n        \"\"\"Cierra la conexi√≥n\"\"\"\n        if self.connection and not self.connection.is_closed:\n            self.connection.close()\n            logger.info(\"üëã Conexi√≥n a RabbitMQ cerrada\")",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 149
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/services/notification_publisher.py",
      "timestamp": 1762898477574,
      "startOffset": 0,
      "endOffset": 4241,
      "codeContent": "import pika\nimport json\nimport logging\nfrom datetime import datetime\nfrom app.config.settings import settings\nfrom app.models.events import NotificationEvent, NotificationType\n\nlogger \u003d logging.getLogger(__name__)\n\nclass NotificationPublisher:\n    def __init__(self):\n        self.connection \u003d None\n        self.channel \u003d None\n        self.setup_connection()\n    \n    def setup_connection(self):\n        \"\"\"Establece conexi√≥n con RabbitMQ para publicar\"\"\"\n        credentials \u003d pika.PlainCredentials(\n            settings.rabbitmq_user,\n            settings.rabbitmq_password\n        )\n        parameters \u003d pika.ConnectionParameters(\n            host\u003dsettings.rabbitmq_host,\n            port\u003dsettings.rabbitmq_port,\n            credentials\u003dcredentials,\n            heartbeat\u003d600,\n            blocked_connection_timeout\u003d300\n        )\n        \n        self.connection \u003d pika.BlockingConnection(parameters)\n        self.channel \u003d self.connection.channel()\n        \n        # Declarar cola de notificaciones\n        self.channel.queue_declare(\n            queue\u003dsettings.notifications_queue,\n            durable\u003dTrue\n        )\n        \n        logger.info(\"‚úÖ Publicador de notificaciones configurado\")\n    \n    def publish_notification(self, notification: NotificationEvent):\n        \"\"\"Publica una notificaci√≥n al servicio de delivery\"\"\"\n        try:\n            message \u003d notification.model_dump(mode\u003d\u0027json\u0027, by_alias\u003dTrue)\n            \n            self.channel.basic_publish(\n                exchange\u003dsettings.exchange_name,\n                routing_key\u003dsettings.notifications_routing_key,\n                body\u003djson.dumps(message, default\u003dstr),\n                properties\u003dpika.BasicProperties(\n                    delivery_mode\u003d2,  # Mensaje persistente\n                    content_type\u003d\u0027application/json\u0027\n                )\n            )\n            \n            logger.info(f\"üì§ Notificaci√≥n publicada: {notification.type} -\u003e {notification.email}\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error publicando notificaci√≥n: {e}\")\n            raise\n    \n    def create_user_welcome_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"Crea notificaci√≥n de bienvenida\"\"\"\n        additional_data \u003d {}\n        if hasattr(event, \u0027activation_token\u0027) and event.activation_token:\n            additional_data[\u0027activationToken\u0027] \u003d event.activation_token\n        \n        return NotificationEvent(\n            type\u003dNotificationType.USER_WELCOME,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003ddatetime.now(),\n            additional_data\u003dadditional_data if additional_data else None\n        )\n    \n    def create_login_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"Crea notificaci√≥n de inicio de sesi√≥n\"\"\"\n        additional_data \u003d {\n            \u0027ipAddress\u0027: event.ip_address,\n            \u0027userAgent\u0027: event.user_agent,\n            \u0027deviceInfo\u0027: event.device_info,\n            \u0027location\u0027: event.location\n        }\n        \n        return NotificationEvent(\n            type\u003dNotificationType.LOGIN_NOTIFICATION,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.timestamp,\n            additional_data\u003dadditional_data\n        )\n    \n    def create_password_reset_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"Crea notificaci√≥n de reset de contrase√±a\"\"\"\n        return NotificationEvent(\n            type\u003dNotificationType.PASSWORD_RESET,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.fecha_solicitud,\n            additional_data\u003d{\u0027resetToken\u0027: event.token}\n        )\n    \n    def create_password_updated_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"Crea notificaci√≥n de contrase√±a actualizada\"\"\"\n        return NotificationEvent(\n            type\u003dNotificationType.PASSWORD_UPDATED,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.fecha_actualizacion,\n            additional_data\u003dNone\n        )\n    \n    def close(self):\n        \"\"\"Cierra la conexi√≥n\"\"\"\n        if self.connection and not self.connection.is_closed:\n            self.connection.close()\n            logger.info(\"üëã Publicador cerrado\")",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 117
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/main.py",
      "timestamp": 1762898493798,
      "startOffset": 0,
      "endOffset": 4272,
      "codeContent": "import logging\nimport signal\nimport sys\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nimport threading\n\nfrom app.config.settings import settings\nfrom app.services.rabbitmq_consumer import RabbitMQConsumer\nfrom app.services.notification_publisher import NotificationPublisher\nfrom app.utils.logger import setup_logging\n\n# Configurar logging\nsetup_logging()\nlogger \u003d logging.getLogger(__name__)\n\n# Variables globales para los servicios\nconsumer \u003d None\npublisher \u003d None\nconsumer_thread \u003d None\n\ndef handle_usuario_creado(event):\n    \"\"\"Handler para eventos de usuario creado\"\"\"\n    logger.info(f\"üì© Usuario creado recibido: {event.email}\")\n    try:\n        notification \u003d publisher.create_user_welcome_notification(event)\n        publisher.publish_notification(notification)\n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando usuario creado: {e}\")\n\ndef handle_sesion_iniciada(event):\n    \"\"\"Handler para eventos de sesi√≥n iniciada\"\"\"\n    logger.info(f\"üì© Sesi√≥n iniciada recibida: {event.email}\")\n    try:\n        notification \u003d publisher.create_login_notification(event)\n        publisher.publish_notification(notification)\n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando sesi√≥n iniciada: {e}\")\n\ndef handle_password_reset(event):\n    \"\"\"Handler para eventos de reset de password\"\"\"\n    logger.info(f\"üì© Password reset recibido: {event.email}\")\n    try:\n        notification \u003d publisher.create_password_reset_notification(event)\n        publisher.publish_notification(notification)\n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando password reset: {e}\")\n\ndef handle_password_updated(event):\n    \"\"\"Handler para eventos de password actualizado\"\"\"\n    logger.info(f\"üì© Password updated recibido: {event.email}\")\n    try:\n        notification \u003d publisher.create_password_updated_notification(event)\n        publisher.publish_notification(notification)\n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando password updated: {e}\")\n\ndef start_rabbitmq_consumers():\n    \"\"\"Inicia los consumidores de RabbitMQ\"\"\"\n    global consumer, publisher\n    \n    try:\n        consumer \u003d RabbitMQConsumer()\n        publisher \u003d NotificationPublisher()\n        \n        # Registrar consumers\n        consumer.consume_usuarios(handle_usuario_creado)\n        consumer.consume_sesiones(handle_sesion_iniciada)\n        consumer.consume_password_reset(handle_password_reset)\n        consumer.consume_password_updated(handle_password_updated)\n        \n        # Iniciar consumo\n        consumer.start_consuming()\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error en consumidores: {e}\")\n        sys.exit(1)\n\ndef signal_handler(signum, frame):\n    \"\"\"Maneja se√±ales de terminaci√≥n\"\"\"\n    logger.info(\"‚ö†Ô∏è Se√±al de terminaci√≥n recibida, cerrando...\")\n    if consumer:\n        consumer.close()\n    if publisher:\n        publisher.close()\n    sys.exit(0)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Gestiona el ciclo de vida de la aplicaci√≥n\"\"\"\n    global consumer_thread\n    \n    # Startup\n    logger.info(f\"üöÄ Iniciando {settings.app_name} v{settings.app_version}\")\n    \n    # Registrar signal handlers\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n    \n    # Iniciar consumidores en un thread separado\n    consumer_thread \u003d threading.Thread(target\u003dstart_rabbitmq_consumers, daemon\u003dTrue)\n    consumer_thread.start()\n    \n    yield\n    \n    # Shutdown\n    logger.info(\"üëã Cerrando aplicaci√≥n...\")\n    if consumer:\n        consumer.close()\n    if publisher:\n        publisher.close()\n\n# Crear aplicaci√≥n FastAPI\napp \u003d FastAPI(\n    title\u003dsettings.app_name,\n    version\u003dsettings.app_version,\n    lifespan\u003dlifespan\n)\n\n@app.get(\"/\")\nasync def root():\n    return {\n        \"service\": settings.app_name,\n        \"version\": settings.app_version,\n        \"status\": \"running\"\n    }\n\n@app.get(\"/health\")\nasync def health():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"service\": settings.app_name\n    }\n\nif __name__ \u003d\u003d \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"app.main:app\",\n        host\u003d\"0.0.0.0\",\n        port\u003dsettings.port,\n        log_level\u003dsettings.log_level.lower()\n    )",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 143
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/utils/logger.py",
      "timestamp": 1762898509341,
      "startOffset": 0,
      "endOffset": 482,
      "codeContent": "import logging\nimport sys\nfrom pythonjsonlogger import jsonlogger\n\ndef setup_logging():\n    \"\"\"Configura el logging con formato JSON\"\"\"\n    logger \u003d logging.getLogger()\n    logger.setLevel(logging.INFO)\n    \n    # Handler para stdout\n    handler \u003d logging.StreamHandler(sys.stdout)\n    \n    # Formato JSON\n    formatter \u003d jsonlogger.JsonFormatter(\n        \u0027%(asctime)s %(name)s %(levelname)s %(message)s\u0027\n    )\n    handler.setFormatter(formatter)\n    \n    logger.addHandler(handler)",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 19
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/test-automation/src/test/java/co/edu/uniquindio/tests/steps/UserSteps.java",
      "timestamp": 1762899815397,
      "startOffset": 71,
      "endOffset": 6833,
      "codeContent": "support.ApiClient;\nimport co.edu.uniquindio.tests.support.AuthClient;\nimport co.edu.uniquindio.tests.utils.UsersData;\nimport io.cucumber.java.es.*;\nimport io.restassured.response.Response;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class UsuariosSteps {\n    \n    private AuthClient authClient;\n    private ApiClient apiClient;\n    private String adminToken;\n    private UsersData.User nuevoUsuario;\n    private Response response;\n    private String usuarioId;\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ANTECEDENTES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    \n    @Dado(\"que el sistema de gesti√≥n de usuarios est√° disponible\")\n    public void sistemaDisponible() {\n        authClient \u003d new AuthClient();\n        assertNotNull(authClient, \"El cliente de autenticaci√≥n debe estar disponible\");\n    }\n\n    @Dado(\"que tengo credenciales de administrador v√°lidas\")\n    public void credencialesAdmin() {\n        // Las credenciales est√°n en TestConfig\n        assertTrue(true, \"Credenciales de admin configuradas\");\n    }\n\n    @Dado(\"que obtengo un token de autenticaci√≥n como administrador\")\n    public void obtenerTokenAdmin() {\n        adminToken \u003d authClient.getAdminAccessToken();\n        assertNotNull(adminToken, \"Debe obtener token de admin\");\n        apiClient \u003d new ApiClient(adminToken);\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d GIVEN \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n    @Dado(\"que tengo los datos de un nuevo usuario\")\n    public void datosNuevoUsuario() {\n        nuevoUsuario \u003d UsersData.randomUser();\n        assertNotNull(nuevoUsuario, \"Datos de usuario generados\");\n    }\n\n    @Dado(\"que existe un usuario en el sistema\")\n    public void usuarioExiste() {\n        nuevoUsuario \u003d UsersData.randomUser();\n        response \u003d apiClient.createUser(\n            nuevoUsuario.nombre(),\n            nuevoUsuario.email(),\n            nuevoUsuario.password()\n        );\n        \n        int statusCode \u003d response.statusCode();\n        assertTrue(\n            statusCode \u003d\u003d 200 || statusCode \u003d\u003d 201,\n            \"Usuario debe ser creado. Status: \" + statusCode\n        );\n        \n        usuarioId \u003d response.jsonPath().getString(\"id\");\n        assertNotNull(usuarioId, \"Usuario debe tener ID\");\n    }\n\n    @Dado(\"que tengo nuevos datos para actualizar\")\n    public void nuevosDatosActualizar() {\n        // Generar nuevos datos para actualizaci√≥n\n        nuevoUsuario \u003d new UsersData.User(\n            \"Nombre Actualizado\",\n            nuevoUsuario.email(),\n            nuevoUsuario.password()\n        );\n    }\n\n    @Dado(\"que existen m√∫ltiples usuarios en el sistema\")\n    public void multiplesusuarios() {\n        // Crear al menos 3 usuarios\n        for (int i \u003d 0; i \u003c 3; i++) {\n            UsersData.User user \u003d UsersData.randomUser();\n            apiClient.createUser(user.nombre(), user.email(), user.password());\n        }\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d WHEN \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n    @Cuando(\"env√≠o una solicitud para crear el usuario\")\n    public void crearUsuario() {\n        response \u003d apiClient.createUser(\n            nuevoUsuario.nombre(),\n            nuevoUsuario.email(),\n            nuevoUsuario.password()\n        );\n    }\n\n    @Cuando(\"consulto el usuario por su ID\")\n    public void consultarPorId() {\n        response \u003d apiClient.getUserById(usuarioId);\n    }\n\n    @Cuando(\"env√≠o una solicitud de actualizaci√≥n\")\n    public void actualizarUsuario() {\n        response \u003d apiClient.updateUser(\n            usuarioId,\n            nuevoUsuario.nombre()\n        );\n    }\n\n    @Cuando(\"env√≠o una solicitud de eliminaci√≥n\")\n    public void eliminarUsuario() {\n        response \u003d apiClient.deleteUser(usuarioId);\n    }\n\n    @Cuando(\"consulto la lista de usuarios\")\n    public void listarUsuarios() {\n        response \u003d apiClient.getAllUsers();\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d THEN \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n    @Entonces(\"el usuario debe ser creado con c√≥digo {int}\")\n    public void verificarCreadoConCodigo(int expectedCode) {\n        assertEquals(expectedCode, response.statusCode(),\n            \"C√≥digo de respuesta incorrecto\");\n    }\n\n    @Entonces(\"debe tener un ID asignado\")\n    public void verificarIdAsignado() {\n        usuarioId \u003d response.jsonPath().getString(\"id\");\n        assertNotNull(usuarioId, \"El usuario debe tener un ID\");\n        assertFalse(usuarioId.isEmpty(), \"El ID no debe estar vac√≠o\");\n    }\n\n    @Entonces(\"debe estar almacenado en la base de datos\")\n    public void verificarEnBaseDatos() {\n        // Verificar consultando el usuario reci√©n creado\n        Response verification \u003d apiClient.getUserById(usuarioId);\n        assertEquals(200, verification.statusCode(),\n            \"El usuario debe existir en la BD\");\n    }\n\n    @Entonces(\"debe retornar el usuario con c√≥digo {int}\")\n    public void verificarRetornoConCodigo(int expectedCode) {\n        assertEquals(expectedCode, response.statusCode(),\n            \"C√≥digo de respuesta incorrecto\");\n    }\n\n    @Entonces(\"los datos deben coincidir con los almacenados\")\n    public void verificarDatosCoinciden() {\n        String email \u003d response.jsonPath().getString(\"email\");\n        assertEquals(nuevoUsuario.email(), email,\n            \"El email debe coincidir\");\n    }\n\n    @Entonces(\"los datos deben actualizarse con c√≥digo {int}\")\n    public void verificarActualizacionConCodigo(int expectedCode) {\n        assertEquals(expectedCode, response.statusCode(),\n            \"C√≥digo de actualizaci√≥n incorrecto\");\n    }\n\n    @Entonces(\"los cambios deben reflejarse en la base de datos\")\n    public void verificarCambiosEnBD() {\n        Response verification \u003d apiClient.getUserById(usuarioId);\n        String nombre \u003d verification.jsonPath().getString(\"nombre\");\n        assertEquals(nuevoUsuario.nombre(), nombre,\n            \"El nombre actualizado debe reflejarse en la BD\");\n    }\n\n    @Entonces(\"el usuario debe ser eliminado con c√≥digo {int}\")\n    public void verificarEliminadoConCodigo(int expectedCode) {\n        assertEquals(expectedCode, response.statusCode(),\n            \"C√≥digo de eliminaci√≥n incorrecto\");\n    }\n\n    @Entonces(\"no debe existir m√°s en la base de datos\")\n    public void verificarNoExisteEnBD() {\n        Response verification \u003d apiClient.getUserById(usuarioId);\n        assertEquals(404, verification.statusCode(),\n            \"El usuario eliminado no debe existir\");\n    }\n\n    @Entonces(\"debe retornar la lista con c√≥digo {int}\")\n    public void verificarListaConCodigo(int expectedCode) {\n        assertEquals(expectedCode, response.statusCode(),\n            \"C√≥digo de respuesta de lista incorrecto\");\n    }\n\n    @Entonces(\"debe contener todos los usuarios registrados\")\n    public void verificarListaCompleta() {\n        int usuariosCount \u003d response.jsonPath().getList(\"$\").size();\n        assertThat(usuariosCount, greaterThan(0",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 193
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/services/rabbitmq_consumer.py",
      "timestamp": 1762900804562,
      "startOffset": 163,
      "endOffset": 8467,
      "codeContent": " \n    SesionIniciadaEvent,\n    PasswordResetSolicitadoEvent,\n    PasswordActualizadoEvent\n)\n\nlogger \u003d logging.getLogger(__name__)\n\nclass RabbitMQConsumer:\n    \"\"\"\n    Consumidor de mensajes de RabbitMQ.\n    Escucha m√∫ltiples colas y procesa eventos de dominio.\n    \"\"\"\n    \n    def __init__(self):\n        self.connection \u003d None\n        self.channel \u003d None\n        self.setup_connection()\n    \n    def setup_connection(self):\n        \"\"\"Establece conexi√≥n con RabbitMQ\"\"\"\n        try:\n            credentials \u003d pika.PlainCredentials(\n                settings.rabbitmq_user,\n                settings.rabbitmq_password\n            )\n            parameters \u003d pika.ConnectionParameters(\n                host\u003dsettings.rabbitmq_host,\n                port\u003dsettings.rabbitmq_port,\n                credentials\u003dcredentials,\n                heartbeat\u003d600,\n                blocked_connection_timeout\u003d300\n            )\n            \n            self.connection \u003d pika.BlockingConnection(parameters)\n            self.channel \u003d self.connection.channel()\n            \n            # Declarar exchange con tipo topic para routing flexible\n            self.channel.exchange_declare(\n                exchange\u003dsettings.exchange_name,\n                exchange_type\u003d\u0027topic\u0027,\n                durable\u003dTrue\n            )\n            \n            # Declarar todas las colas necesarias\n            self._declare_queues()\n            \n            logger.info(\"‚úÖ Conexi√≥n a RabbitMQ establecida exitosamente\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error estableciendo conexi√≥n a RabbitMQ: {e}\")\n            raise\n    \n    def _declare_queues(self):\n        \"\"\"\n        Declara todas las colas necesarias y las vincula al exchange.\n        Cada cola se asocia con su routing key espec√≠fico.\n        \"\"\"\n        queues_config \u003d [\n            (settings.usuarios_queue, \"usuarios.created\"),\n            (settings.sesiones_queue, \"sesiones.iniciada\"),\n            (settings.password_reset_queue, \"password.reset.requested\"),\n            (settings.password_updated_queue, \"password.updated\"),\n        ]\n        \n        for queue_name, routing_key in queues_config:\n            # Declarar cola como durable para persistencia\n            self.channel.queue_declare(queue\u003dqueue_name, durable\u003dTrue)\n            \n            # Vincular cola al exchange con routing key\n            self.channel.queue_bind(\n                exchange\u003dsettings.exchange_name,\n                queue\u003dqueue_name,\n                routing_key\u003drouting_key\n            )\n            \n            logger.info(f\"‚úÖ Cola configurada: {queue_name} -\u003e {routing_key}\")\n    \n    def consume_usuarios(self, callback: Callable):\n        \"\"\"\n        Consume eventos de usuarios creados.\n        \n        Args:\n            callback: Funci√≥n a ejecutar cuando se reciba un mensaje\n        \"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                # Deserializar mensaje JSON\n                data \u003d json.loads(body.decode(\u0027utf-8\u0027))\n                logger.debug(f\"üì© Mensaje recibido en usuarios.events: {data}\")\n                \n                # Parsear a objeto Pydantic para validaci√≥n\n                event \u003d UsuarioCreadoEvent(**data)\n                \n                # Ejecutar callback\n                callback(event)\n                \n                # Confirmar procesamiento exitoso\n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n                logger.debug(f\"‚úÖ Mensaje procesado y confirmado\")\n                \n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de usuario: {e}\")\n                # Rechazar mensaje sin reencolar (evita loops infinitos)\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        # Configurar consumidor\n        self.channel.basic_consume(\n            queue\u003dsettings.usuarios_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.usuarios_queue}\")\n    \n    def consume_sesiones(self, callback: Callable):\n        \"\"\"\n        Consume eventos de sesiones iniciadas.\n        \n        Args:\n            callback: Funci√≥n a ejecutar cuando se reciba un mensaje\n        \"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                data \u003d json.loads(body.decode(\u0027utf-8\u0027))\n                logger.debug(f\"üì© Mensaje recibido en sesiones.events: {data}\")\n                \n                event \u003d SesionIniciadaEvent(**data)\n                callback(event)\n                \n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n                logger.debug(f\"‚úÖ Mensaje procesado y confirmado\")\n                \n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de sesi√≥n: {e}\")\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        self.channel.basic_consume(\n            queue\u003dsettings.sesiones_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.sesiones_queue}\")\n    \n    def consume_password_reset(self, callback: Callable):\n        \"\"\"\n        Consume eventos de reset de password solicitados.\n        \n        Args:\n            callback: Funci√≥n a ejecutar cuando se reciba un mensaje\n        \"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                data \u003d json.loads(body.decode(\u0027utf-8\u0027))\n                logger.debug(f\"üì© Mensaje recibido en password.reset.requested: {data}\")\n                \n                event \u003d PasswordResetSolicitadoEvent(**data)\n                callback(event)\n                \n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n                logger.debug(f\"‚úÖ Mensaje procesado y confirmado\")\n                \n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de password reset: {e}\")\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        self.channel.basic_consume(\n            queue\u003dsettings.password_reset_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.password_reset_queue}\")\n    \n    def consume_password_updated(self, callback: Callable):\n        \"\"\"\n        Consume eventos de password actualizado.\n        \n        Args:\n            callback: Funci√≥n a ejecutar cuando se reciba un mensaje\n        \"\"\"\n        def on_message(ch, method, properties, body):\n            try:\n                data \u003d json.loads(body.decode(\u0027utf-8\u0027))\n                logger.debug(f\"üì© Mensaje recibido en password.updated: {data}\")\n                \n                event \u003d PasswordActualizadoEvent(**data)\n                callback(event)\n                \n                ch.basic_ack(delivery_tag\u003dmethod.delivery_tag)\n                logger.debug(f\"‚úÖ Mensaje procesado y confirmado\")\n                \n            except Exception as e:\n                logger.error(f\"‚ùå Error procesando evento de password updated: {e}\")\n                ch.basic_nack(delivery_tag\u003dmethod.delivery_tag, requeue\u003dFalse)\n        \n        self.channel.basic_consume(\n            queue\u003dsettings.password_updated_queue,\n            on_message_callback\u003don_message\n        )\n        logger.info(f\"üëÇ Escuchando en cola: {settings.password_updated_queue}\")\n    \n    def start_consuming(self):\n        \"\"\"\n        Inicia el consumo de mensajes.\n        Este m√©todo es bloqueante y mantendr√° el proceso corriendo.\n        \"\"\"\n        logger.info(\"üöÄ Iniciando consumo de mensajes...\")\n        try:\n            self.channel.start_consuming()\n        except KeyboardInterrupt:\n            logger.info(\"‚ö†Ô∏è Consumo interrumpido por el usuario\")\n            self.close()\n        except Exception as e:\n            logger.error(f\"‚ùå Error durante el consumo: {e}\")\n            self.close()\n            raise\n    \n    def close(self):\n        \"\"\"Cierra la conexi√≥n a RabbitMQ de forma segura\"\"\"\n        try:\n            if self.connection and not self.connection.is_closed:\n                self.connection.close()\n                logger.info(\"üëã Conexi√≥n a RabbitMQ cerrada\")\n        except Exception as e:\n            logger.error(f\"‚ùå Error cerrando conexi√≥n: {e}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 221
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/services/notification_publisher.py",
      "timestamp": 1762900826701,
      "startOffset": 248,
      "endOffset": 6999,
      "codeContent": "\"\"\"\n    Publicador de eventos de notificaci√≥n hacia el servicio de Delivery.\n    Transforma eventos de dominio en eventos de notificaci√≥n.\n    \"\"\"\n    \n    def __init__(self):\n        self.connection \u003d None\n        self.channel \u003d None\n        self.setup_connection()\n    \n    def setup_connection(self):\n        \"\"\"Establece conexi√≥n con RabbitMQ para publicar mensajes\"\"\"\n        try:\n            credentials \u003d pika.PlainCredentials(\n                settings.rabbitmq_user,\n                settings.rabbitmq_password\n            )\n            parameters \u003d pika.ConnectionParameters(\n                host\u003dsettings.rabbitmq_host,\n                port\u003dsettings.rabbitmq_port,\n                credentials\u003dcredentials,\n                heartbeat\u003d600,\n                blocked_connection_timeout\u003d300\n            )\n            \n            self.connection \u003d pika.BlockingConnection(parameters)\n            self.channel \u003d self.connection.channel()\n            \n            # Declarar cola de destino (notifications.delivery)\n            self.channel.queue_declare(\n                queue\u003dsettings.notifications_queue,\n                durable\u003dTrue\n            )\n            \n            logger.info(\"‚úÖ Publicador de notificaciones configurado exitosamente\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error configurando publicador: {e}\")\n            raise\n    \n    def publish_notification(self, notification: NotificationEvent):\n        \"\"\"\n        Publica una notificaci√≥n al servicio de Delivery.\n        \n        Args:\n            notification: Evento de notificaci√≥n a publicar\n            \n        Raises:\n            RuntimeError: Si ocurre un error al publicar\n        \"\"\"\n        try:\n            # Serializar el evento a JSON usando el esquema de Pydantic\n            message \u003d notification.model_dump(mode\u003d\u0027json\u0027, by_alias\u003dTrue)\n            \n            logger.debug(f\"üöÄ Publicando NotificationEvent: {notification.type} -\u003e {notification.email}\")\n            \n            # Publicar mensaje\n            self.channel.basic_publish(\n                exchange\u003dsettings.exchange_name,\n                routing_key\u003dsettings.notifications_routing_key,\n                body\u003djson.dumps(message, default\u003dstr),\n                properties\u003dpika.BasicProperties(\n                    delivery_mode\u003d2,  # Mensaje persistente\n                    content_type\u003d\u0027application/json\u0027,\n                    timestamp\u003dint(datetime.now().timestamp())\n                )\n            )\n            \n            logger.info(f\"üì§ Notificaci√≥n publicada exitosamente: {notification.type} -\u003e {notification.email}\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error publicando notificaci√≥n: {e}\")\n            raise RuntimeError(f\"Error publicando notificaci√≥n: {e}\")\n    \n    def create_user_welcome_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de bienvenida a partir de un evento de usuario creado.\n        \n        Args:\n            event: UsuarioCreadoEvent\n            \n        Returns:\n            NotificationEvent configurado para bienvenida\n        \"\"\"\n        additional_data \u003d {}\n        \n        # Si hay token de activaci√≥n, incluirlo\n        if hasattr(event, \u0027activation_token\u0027) and event.activation_token:\n            additional_data[\u0027activationToken\u0027] \u003d event.activation_token\n        \n        # Si hay base URL, incluirla\n        if hasattr(event, \u0027base_url\u0027) and event.base_url:\n            additional_data[\u0027baseUrl\u0027] \u003d event.base_url\n        \n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.USER_WELCOME,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003ddatetime.now(),\n            additional_data\u003dadditional_data if additional_data else None\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de bienvenida creada para: {event.email}\")\n        return notification\n    \n    def create_login_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de inicio de sesi√≥n.\n        \n        Args:\n            event: SesionIniciadaEvent\n            \n        Returns:\n            NotificationEvent configurado para notificaci√≥n de login\n        \"\"\"\n        additional_data \u003d {\n            \u0027ipAddress\u0027: event.ip_address if event.ip_address else \u0027Desconocida\u0027,\n            \u0027userAgent\u0027: event.user_agent if event.user_agent else \u0027Desconocido\u0027,\n            \u0027deviceInfo\u0027: event.device_info if event.device_info else \u0027Desconocido\u0027,\n            \u0027location\u0027: event.location if event.location else \u0027Desconocida\u0027\n        }\n        \n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.LOGIN_NOTIFICATION,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.timestamp,\n            additional_data\u003dadditional_data\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de login creada para: {event.email}\")\n        return notification\n    \n    def create_password_reset_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de reset de contrase√±a.\n        \n        Args:\n            event: PasswordResetSolicitadoEvent\n            \n        Returns:\n            NotificationEvent configurado para reset de password\n        \"\"\"\n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.PASSWORD_RESET,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.fecha_solicitud,\n            additional_data\u003d{\u0027resetToken\u0027: event.token}\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de reset de password creada para: {event.email}\")\n        return notification\n    \n    def create_password_updated_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de contrase√±a actualizada.\n        \n        Args:\n            event: PasswordActualizadoEvent\n            \n        Returns:\n            NotificationEvent configurado para password actualizado\n        \"\"\"\n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.PASSWORD_UPDATED,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.fecha_actualizacion,\n            additional_data\u003dNone\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de password actualizado creada para: {event.email}\")\n        return notification\n    \n    def close(self):\n        \"\"\"Cierra la conexi√≥n al publicador\"\"\"\n        try:\n            if self.connection and not self.connection.is_closed:\n                self.connection.close()\n                logger.info(\"üëã Publicador cerrado\")\n        except Exception as e:\n            logger.error(f\"‚ùå Error cerrando publicador: {e}",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 183
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/services/notification_publisher.py",
      "timestamp": 1762900829597,
      "startOffset": 248,
      "endOffset": 6999,
      "codeContent": "\"\"\"\n    Publicador de eventos de notificaci√≥n hacia el servicio de Delivery.\n    Transforma eventos de dominio en eventos de notificaci√≥n.\n    \"\"\"\n    \n    def __init__(self):\n        self.connection \u003d None\n        self.channel \u003d None\n        self.setup_connection()\n    \n    def setup_connection(self):\n        \"\"\"Establece conexi√≥n con RabbitMQ para publicar mensajes\"\"\"\n        try:\n            credentials \u003d pika.PlainCredentials(\n                settings.rabbitmq_user,\n                settings.rabbitmq_password\n            )\n            parameters \u003d pika.ConnectionParameters(\n                host\u003dsettings.rabbitmq_host,\n                port\u003dsettings.rabbitmq_port,\n                credentials\u003dcredentials,\n                heartbeat\u003d600,\n                blocked_connection_timeout\u003d300\n            )\n            \n            self.connection \u003d pika.BlockingConnection(parameters)\n            self.channel \u003d self.connection.channel()\n            \n            # Declarar cola de destino (notifications.delivery)\n            self.channel.queue_declare(\n                queue\u003dsettings.notifications_queue,\n                durable\u003dTrue\n            )\n            \n            logger.info(\"‚úÖ Publicador de notificaciones configurado exitosamente\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error configurando publicador: {e}\")\n            raise\n    \n    def publish_notification(self, notification: NotificationEvent):\n        \"\"\"\n        Publica una notificaci√≥n al servicio de Delivery.\n        \n        Args:\n            notification: Evento de notificaci√≥n a publicar\n            \n        Raises:\n            RuntimeError: Si ocurre un error al publicar\n        \"\"\"\n        try:\n            # Serializar el evento a JSON usando el esquema de Pydantic\n            message \u003d notification.model_dump(mode\u003d\u0027json\u0027, by_alias\u003dTrue)\n            \n            logger.debug(f\"üöÄ Publicando NotificationEvent: {notification.type} -\u003e {notification.email}\")\n            \n            # Publicar mensaje\n            self.channel.basic_publish(\n                exchange\u003dsettings.exchange_name,\n                routing_key\u003dsettings.notifications_routing_key,\n                body\u003djson.dumps(message, default\u003dstr),\n                properties\u003dpika.BasicProperties(\n                    delivery_mode\u003d2,  # Mensaje persistente\n                    content_type\u003d\u0027application/json\u0027,\n                    timestamp\u003dint(datetime.now().timestamp())\n                )\n            )\n            \n            logger.info(f\"üì§ Notificaci√≥n publicada exitosamente: {notification.type} -\u003e {notification.email}\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error publicando notificaci√≥n: {e}\")\n            raise RuntimeError(f\"Error publicando notificaci√≥n: {e}\")\n    \n    def create_user_welcome_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de bienvenida a partir de un evento de usuario creado.\n        \n        Args:\n            event: UsuarioCreadoEvent\n            \n        Returns:\n            NotificationEvent configurado para bienvenida\n        \"\"\"\n        additional_data \u003d {}\n        \n        # Si hay token de activaci√≥n, incluirlo\n        if hasattr(event, \u0027activation_token\u0027) and event.activation_token:\n            additional_data[\u0027activationToken\u0027] \u003d event.activation_token\n        \n        # Si hay base URL, incluirla\n        if hasattr(event, \u0027base_url\u0027) and event.base_url:\n            additional_data[\u0027baseUrl\u0027] \u003d event.base_url\n        \n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.USER_WELCOME,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003ddatetime.now(),\n            additional_data\u003dadditional_data if additional_data else None\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de bienvenida creada para: {event.email}\")\n        return notification\n    \n    def create_login_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de inicio de sesi√≥n.\n        \n        Args:\n            event: SesionIniciadaEvent\n            \n        Returns:\n            NotificationEvent configurado para notificaci√≥n de login\n        \"\"\"\n        additional_data \u003d {\n            \u0027ipAddress\u0027: event.ip_address if event.ip_address else \u0027Desconocida\u0027,\n            \u0027userAgent\u0027: event.user_agent if event.user_agent else \u0027Desconocido\u0027,\n            \u0027deviceInfo\u0027: event.device_info if event.device_info else \u0027Desconocido\u0027,\n            \u0027location\u0027: event.location if event.location else \u0027Desconocida\u0027\n        }\n        \n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.LOGIN_NOTIFICATION,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.timestamp,\n            additional_data\u003dadditional_data\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de login creada para: {event.email}\")\n        return notification\n    \n    def create_password_reset_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de reset de contrase√±a.\n        \n        Args:\n            event: PasswordResetSolicitadoEvent\n            \n        Returns:\n            NotificationEvent configurado para reset de password\n        \"\"\"\n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.PASSWORD_RESET,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.fecha_solicitud,\n            additional_data\u003d{\u0027resetToken\u0027: event.token}\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de reset de password creada para: {event.email}\")\n        return notification\n    \n    def create_password_updated_notification(self, event) -\u003e NotificationEvent:\n        \"\"\"\n        Crea una notificaci√≥n de contrase√±a actualizada.\n        \n        Args:\n            event: PasswordActualizadoEvent\n            \n        Returns:\n            NotificationEvent configurado para password actualizado\n        \"\"\"\n        notification \u003d NotificationEvent(\n            type\u003dNotificationType.PASSWORD_UPDATED,\n            email\u003devent.email,\n            user_name\u003devent.nombre,\n            timestamp\u003devent.fecha_actualizacion,\n            additional_data\u003dNone\n        )\n        \n        logger.debug(f\"üìù Notificaci√≥n de password actualizado creada para: {event.email}\")\n        return notification\n    \n    def close(self):\n        \"\"\"Cierra la conexi√≥n al publicador\"\"\"\n        try:\n            if self.connection and not self.connection.is_closed:\n                self.connection.close()\n                logger.info(\"üëã Publicador cerrado\")\n        except Exception as e:\n            logger.error(f\"‚ùå Error cerrando publicador: {e}",
      "aiProbability": 90,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 183
    },
    {
      "filePath": "C:/Users/holda/IdeaProjects/notification-orchestrator-python/app/main.py",
      "timestamp": 1762900848739,
      "startOffset": 364,
      "endOffset": 7380,
      "codeContent": " al inicio\nsetup_logging()\nlogger \u003d logging.getLogger(__name__)\n\n# Variables globales para los servicios\nconsumer \u003d None\npublisher \u003d None\nconsumer_thread \u003d None\n\ndef handle_usuario_creado(event):\n    \"\"\"\n    Handler para eventos de usuario creado.\n    Transforma el evento y lo publica hacia el servicio de Delivery.\n    \"\"\"\n    logger.info(f\"üì© Usuario creado recibido: {event.email}\")\n    try:\n        # Transformar evento de dominio a evento de notificaci√≥n\n        notification \u003d publisher.create_user_welcome_notification(event)\n        \n        # Publicar hacia Delivery\n        publisher.publish_notification(notification)\n        \n        logger.info(f\"‚úÖ Notificaci√≥n de bienvenida procesada para: {event.email}\")\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando usuario creado: {e}\", exc_info\u003dTrue)\n\ndef handle_sesion_iniciada(event):\n    \"\"\"\n    Handler para eventos de sesi√≥n iniciada.\n    \"\"\"\n    logger.info(f\"üì© Sesi√≥n iniciada recibida: {event.email}\")\n    try:\n        notification \u003d publisher.create_login_notification(event)\n        publisher.publish_notification(notification)\n        \n        logger.info(f\"‚úÖ Notificaci√≥n de login procesada para: {event.email}\")\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando sesi√≥n iniciada: {e}\", exc_info\u003dTrue)\n\ndef handle_password_reset(event):\n    \"\"\"\n    Handler para eventos de reset de password solicitado.\n    \"\"\"\n    logger.info(f\"üì© Password reset recibido: {event.email}\")\n    try:\n        notification \u003d publisher.create_password_reset_notification(event)\n        publisher.publish_notification(notification)\n        \n        logger.info(f\"‚úÖ Notificaci√≥n de reset de password procesada para: {event.email}\")\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando password reset: {e}\", exc_info\u003dTrue)\n\ndef handle_password_updated(event):\n    \"\"\"\n    Handler para eventos de password actualizado.\n    \"\"\"\n    logger.info(f\"üì© Password updated recibido: {event.email}\")\n    try:\n        notification \u003d publisher.create_password_updated_notification(event)\n        publisher.publish_notification(notification)\n        \n        logger.info(f\"‚úÖ Notificaci√≥n de password actualizado procesada para: {event.email}\")\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error procesando password updated: {e}\", exc_info\u003dTrue)\n\ndef start_rabbitmq_consumers():\n    \"\"\"\n    Inicia los consumidores de RabbitMQ.\n    Esta funci√≥n se ejecuta en un thread separado.\n    \"\"\"\n    global consumer, publisher\n    \n    try:\n        logger.info(\"üîß Configurando consumidores de RabbitMQ...\")\n        \n        # Crear instancias de consumer y publisher\n        consumer \u003d RabbitMQConsumer()\n        publisher \u003d NotificationPublisher()\n        \n        # Registrar handlers para cada tipo de evento\n        consumer.consume_usuarios(handle_usuario_creado)\n        consumer.consume_sesiones(handle_sesion_iniciada)\n        consumer.consume_password_reset(handle_password_reset)\n        consumer.consume_password_updated(handle_password_updated)\n        \n        logger.info(\"‚úÖ Consumidores configurados. Iniciando consumo...\")\n        \n        # Iniciar consumo (bloqueante)\n        consumer.start_consuming()\n        \n    except KeyboardInterrupt:\n        logger.info(\"‚ö†Ô∏è Consumo interrumpido por se√±al\")\n    except Exception as e:\n        logger.error(f\"‚ùå Error en consumidores: {e}\", exc_info\u003dTrue)\n        sys.exit(1)\n\ndef signal_handler(signum, frame):\n    \"\"\"\n    Maneja se√±ales de terminaci√≥n (SIGINT, SIGTERM).\n    Permite un cierre graceful de las conexiones.\n    \"\"\"\n    logger.info(f\"‚ö†Ô∏è Se√±al {signum} recibida, cerrando aplicaci√≥n...\")\n    \n    # Cerrar consumer\n    if consumer:\n        try:\n            consumer.close()\n        except Exception as e:\n            logger.error(f\"Error cerrando consumer: {e}\")\n    \n    # Cerrar publisher\n    if publisher:\n        try:\n            publisher.close()\n        except Exception as e:\n            logger.error(f\"Error cerrando publisher: {e}\")\n    \n    sys.exit(0)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"\n    Gestiona el ciclo de vida de la aplicaci√≥n FastAPI.\n    Se ejecuta al inicio y al finalizar la aplicaci√≥n.\n    \"\"\"\n    global consumer_thread\n    \n    # \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d STARTUP \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    logger.info(\"\u003d\" * 60)\n    logger.info(f\"üöÄ Iniciando {settings.app_name} v{settings.app_version}\")\n    logger.info(\"\u003d\" * 60)\n    logger.info(f\"üìç RabbitMQ Host: {settings.rabbitmq_host}:{settings.rabbitmq_port}\")\n    logger.info(f\"üìç Exchange: {settings.exchange_name}\")\n    logger.info(f\"üìç Puerto HTTP: {settings.port}\")\n    logger.info(\"\u003d\" * 60)\n    \n    # Registrar signal handlers para cierre graceful\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n    \n    # Iniciar consumidores en un thread separado\n    # (FastAPI corre en el thread principal)\n    logger.info(\"üîÑ Iniciando thread de consumidores...\")\n    consumer_thread \u003d threading.Thread(\n        target\u003dstart_rabbitmq_consumers,\n        daemon\u003dTrue,\n        name\u003d\"RabbitMQConsumerThread\"\n    )\n    consumer_thread.start()\n    logger.info(\"‚úÖ Thread de consumidores iniciado\")\n    \n    # Yield para que la aplicaci√≥n corra\n    yield\n    \n    # \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d SHUTDOWN \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    logger.info(\"\u003d\" * 60)\n    logger.info(\"üëã Cerrando aplicaci√≥n...\")\n    logger.info(\"\u003d\" * 60)\n    \n    # Cerrar conexiones\n    if consumer:\n        consumer.close()\n    if publisher:\n        publisher.close()\n    \n    logger.info(\"‚úÖ Aplicaci√≥n cerrada correctamente\")\n\n# \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d CREAR APLICACI√ìN FASTAPI \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\napp \u003d FastAPI(\n    title\u003dsettings.app_name,\n    version\u003dsettings.app_version,\n    description\u003d\"Microservicio orquestador de notificaciones\",\n    lifespan\u003dlifespan\n)\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Endpoint ra√≠z - informaci√≥n del servicio\"\"\"\n    return {\n        \"service\": settings.app_name,\n        \"version\": settings.app_version,\n        \"status\": \"running\",\n        \"description\": \"Notification Orchestrator - Procesa eventos de dominio y los transforma en notificaciones\"\n    }\n\n@app.get(\"/health\")\nasync def health():\n    \"\"\"\n    Health check endpoint.\n    Usado por Docker y sistemas de orquestaci√≥n para verificar que el servicio est√° vivo.\n    \"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"service\": settings.app_name,\n        \"version\": settings.app_version\n    }\n\n@app.get(\"/metrics\")\nasync def metrics():\n    \"\"\"\n    Endpoint de m√©tricas b√°sicas.\n    Puede extenderse con Prometheus metrics en el futuro.\n    \"\"\"\n    return {\n        \"service\": settings.app_name,\n        \"consumer_running\": consumer_thread.is_alive() if consumer_thread else False\n    }\n\n# \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d PUNTO DE ENTRADA \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nif __name__ \u003d\u003d \"__main__\":\n    import uvicorn\n    \n    logger.info(\"üé¨ Iniciando servidor Uvicorn...\")\n    \n    uvicorn.run(\n        \"app.main:app\",\n        host\u003d\"0.0.0.0\",\n        port\u003dsettings.port,\n        log_level\u003dsettings.log_level.lower(),\n        access_log\u003dTrue",
      "aiProbability": 95,
      "aiTool": "GitHub Copilot",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 224
    }
  ],
  "toolStats": {
    "GitHub Copilot": {
      "usageCount": 11,
      "totalLines": 1528
    }
  }
}